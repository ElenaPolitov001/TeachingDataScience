%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{}
\begin{center}
{\Large Problems and Solutions from LeetCode}
\end{center}

	{\tiny (Ref :  https://www.youtube.com/watch?v=sUicrnHwA0s\&list=PLiC1doDIe9rDFw1v-pPMBYvD6k1ZotNRO)}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{1. Two Sum}

	\begin{itemize}
	\item Given an array of integers, return indices of the two numbers such that they add up to a specific target
	\item \lstinline|nums =  [2,7,11,15], target = 9, as nums[0] + nums[1] = 2 + 7 = 9, return [0,1]|
	\end{itemize}
	
	\begin{columns}[T]
		\column{0.455\linewidth}
		\begin{lstlisting}[basicstyle=\scriptsize]
# Brute force ie two for loops, so O(n^2)
def two_sum_brute(nums, target):
		for i in range(len(nums) - 1):
				for j in range(i + 1, len(nums)):
						if nums[i] + nums[j] == target:
								return [i, j]
		return [-1, -1]		
		\end{lstlisting}
		\column{0.455\linewidth}
		\begin{lstlisting}[basicstyle=\scriptsize]
# Loop once, dictionary based, so O(n)
def two_sum_dict(nums, target):
		seen = {}
		for i, num in enumerate(nums):
				if target - num in seen:
						return [seen[target - num], i]
				elif num not in seen:
						seen[num] = i
		return [-1, -1]	
				\end{lstlisting}		
	\end{columns}
	
	
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{2. Add Two Numbers}


	\begin{itemize}
	\item Given two linked lists representing 2 numbers, digits are stored in reverse order. Add both and return result as list
	\item \lstinline|(2->4->3) + (5->6->4), so numbers are 342 + 465 = 807, so result is (7->0->8)|
	\end{itemize}
	
	\begin{columns}[T]
		\column{0.455\linewidth}
		\begin{lstlisting}[basicstyle=\scriptsize]
# Definition of singly-linked list
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next
				
# position wise addition, and carry forward
def addTwoNumbers(l1, l2):
    added = ListNode(val=(l1.val + l2.val) % 10)
    carry_over = (l1.val + l2.val) // 10
    current_node = added
    while (l1.next and l2.next):
        l1 = l1.next
        l2 = l2.next
				current_sum = carry_over + l1.val + l2.val
        current_node.next = ListNode(val=current_sum % 10)
        carry_over = current_sum // 10
        current_node = current_node.next				
		\end{lstlisting}
		\column{0.455\linewidth}
		\begin{lstlisting}[basicstyle=\scriptsize]
    while(l1.next):
        l1 = l1.next
				current_sum = carry_over + l1.val 
        current_node.next = ListNode(val=current_sum % 10)
        carry_over = current_sum // 10
        current_node = current_node.next

    while(l2.next):
        l2 = l2.next
				current_sum = carry_over + l2.val
        current_node.next = ListNode(val=current_sum % 10)
        carry_over = current_sum // 10
        current_node = current_node.next

    if carry_over > 0:
        current_node.next = ListNode(val=1)
    return added
				\end{lstlisting}		
	\end{columns}
	
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{3. Longest Substring without repeating characters}


	\begin{itemize}
	\item Given a string find the length of the longest substring without repeating characters
	\item \lstinline|"abcabcbb" => 3 for "abc" ; "bbbbbbbbbb" => 1 for "b"|
	\end{itemize}
	
	\begin{columns}[T]
		\column{0.5\linewidth}
	\begin{itemize}
	\item Go on string letters one by one, store each with its index, till you find a duplicate 
	\item In ``abcabcbb'' you will go till 2nd `a', storing \lstinline|{'a'=0,'b'=1,'c'=2}| 
	\item Once duplicate is found, within the same substring, reset start of the next search at letter next to first duplicates ie 2nd 'b'
	\item Capture current substring length as current index which is 3 - index of the first conflict letter, ie 0, so length = 3
	\item Start search similarly from 2nd 'b'
	\end{itemize}
		\column{0.455\linewidth}
		\begin{lstlisting}[basicstyle=\scriptsize]
def lengthOfLongestSubstring(s):
    substring = dict()
    current_substring_start = 0
    current_substring_length = 0
    longest_substring_sofar = 0
    for i, letter in enumerate(s):
        if letter in substring and substring[letter] >= current_substring_start:
            current_substring_start = substring[letter] + 1
            current_substring_length = i - substring[letter]
            substring[letter] = i
        else:
            substring[letter] = i
            current_substring_length += 1
            if current_substring_length > longest_substring_sofar:
                longest_substring_sofar = current_substring_length
    return longest_substring_sofar
				\end{lstlisting}		
	\end{columns}
	
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{5. Longest Palindromic Substring}


	\begin{itemize}
	\item Given a string s, return longest palindromic substring in s
	\item \lstinline|"babad" => "bab", "aba"|
	\item Brute Force: e.g. ``abcbd''. Brute force could be to run 2 for loops, for different ranges, longest to shortest and check for palindrome, return first hit of the longest
	\item Better to find centers having palindrome around it, by expanding step by step. Store biggest so far. Take care of Odd and Even lengths. Find lengthier than current biggest.
	\end{itemize}
	


		\begin{lstlisting}[basicstyle=\scriptsize]
def is_palindrome(s):
    return s == s[::-1]
		
def longestPalindromicSubstring_bruteforce(s):
    for length in range(len(s), 0, -1):  # reverse length numbers
        for start_index in range(0, len(s) + 1 - length):  # different starting points
            current_substring = s[start_index:(start_index + length)]
            if is_palindrome(current_substring):
                return current_substring  # return right away because we are checking the longest first
		\end{lstlisting}		


\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{5. Longest Palindromic Substring}

		\begin{lstlisting}[basicstyle=\scriptsize]
def longestPalindromicSubstring(s):
    biggest = s[0]
    step = len(biggest) // 2  # one side
    # odd case
    for center in range(1, len(s) - 1):
        bounds = [center - (1 + step), center + (1 + step)]  # both directions
        while (bounds[0] > -1) and (bounds[1] < len(s)):  # ends
            current_string = s[bounds[0]:bounds[1] + 1]
            if is_palindrome(current_string):
                biggest = current_string
                step = len(biggest) // 2  # find longer next
                bounds[0] -= 1  # make wider
                bounds[1] += 1
            else:
                break
    # even case
    for center in range(step, len(s) - step - 1):
        bounds = [center - step, center + (1 + step)]  # both directions
        while (bounds[0] > -1) and (bounds[1] < len(s)):  # ends
            current_string = s[bounds[0]:bounds[1] + 1]
            if is_palindrome(current_string):
                biggest = current_string
                step = len(biggest) // 2  # find longer next
                bounds[0] -= 1  # make wider
                bounds[1] += 1
            else:
                break
    return biggest
		\end{lstlisting}		

\end{frame}


