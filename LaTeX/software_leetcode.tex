%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{}
\begin{center}
{\Large Problems and Solutions from LeetCode}
\end{center}

	{\tiny (Ref :  https://www.youtube.com/watch?v=sUicrnHwA0s\&list=PLiC1doDIe9rDFw1v-pPMBYvD6k1ZotNRO)}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{1. Two Sum}

	\begin{itemize}
	\item Given an array of integers, return indices of the two numbers such that they add up to a specific target
	\item \lstinline|nums =  [2,7,11,15], target = 9, as nums[0] + nums[1] = 2 + 7 = 9, return [0,1]|
	\end{itemize}
	
	\begin{columns}[T]
		\column{0.455\linewidth}
		\begin{lstlisting}[basicstyle=\scriptsize]
# Brute force ie two for loops, so O(n^2)
def two_sum_brute(nums, target):
		for i in range(len(nums) - 1):
				for j in range(i + 1, len(nums)):
						if nums[i] + nums[j] == target:
								return [i, j]
		return [-1, -1]		
		\end{lstlisting}
		\column{0.455\linewidth}
		\begin{lstlisting}[basicstyle=\scriptsize]
# Loop once, dictionary based, so O(n)
def two_sum_dict(nums, target):
		seen = {}
		for i, num in enumerate(nums):
				if target - num in seen:
						return [seen[target - num], i]
				elif num not in seen:
						seen[num] = i
		return [-1, -1]	
				\end{lstlisting}		
	\end{columns}
	
	
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{2. Add Two Numbers}


	\begin{itemize}
	\item Given two linked lists representing 2 numbers, digits are stored in reverse order. Add both and return result as list
	\item \lstinline|(2->4->3) + (5->6->4), so numbers are 342 + 465 = 807, so result is (7->0->8)|
	\end{itemize}
	
	\begin{columns}[T]
		\column{0.455\linewidth}
		\begin{lstlisting}[basicstyle=\scriptsize]
# Definition of singly-linked list
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next
				
# position wise addition, and carry forward
def addTwoNumbers(l1, l2):
    added = ListNode(val=(l1.val + l2.val) % 10)
    carry_over = (l1.val + l2.val) // 10
    current_node = added
    while (l1.next and l2.next):
        l1 = l1.next
        l2 = l2.next
				current_sum = carry_over + l1.val + l2.val
        current_node.next = ListNode(val=current_sum % 10)
        carry_over = current_sum // 10
        current_node = current_node.next				
		\end{lstlisting}
		\column{0.455\linewidth}
		\begin{lstlisting}[basicstyle=\scriptsize]
    while(l1.next):
        l1 = l1.next
				current_sum = carry_over + l1.val 
        current_node.next = ListNode(val=current_sum % 10)
        carry_over = current_sum // 10
        current_node = current_node.next

    while(l2.next):
        l2 = l2.next
				current_sum = carry_over + l2.val
        current_node.next = ListNode(val=current_sum % 10)
        carry_over = current_sum // 10
        current_node = current_node.next

    if carry_over > 0:
        current_node.next = ListNode(val=1)
    return added
				\end{lstlisting}		
	\end{columns}
	
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{3. Longest Substring without repeating characters}


	\begin{itemize}
	\item Given a string find the length of the longest substring without repeating characters
	\item \lstinline|"abcabcbb" => 3 for "abc" ; "bbbbbbbbbb" => 1 for "b"|
	\end{itemize}
	
	\begin{columns}[T]
		\column{0.5\linewidth}
	\begin{itemize}
	\item Go on string letters one by one, store each with its index, till you find a duplicate 
	\item In ``abcabcbb'' you will go till 2nd `a', storing \lstinline|{'a'=0,'b'=1,'c'=2}| 
	\item Once duplicate is found, within the same substring, reset start of the next search at letter next to first duplicates ie 2nd 'b'
	\item Capture current substring length as current index which is 3 - index of the first conflict letter, ie 0, so length = 3
	\item Start search similarly from 2nd 'b'
	\end{itemize}
		\column{0.455\linewidth}
		\begin{lstlisting}[basicstyle=\scriptsize]
def lengthOfLongestSubstring(s):
    substring = dict()
    current_substring_start = 0
    current_substring_length = 0
    longest_substring_sofar = 0
    for i, letter in enumerate(s):
        if letter in substring and substring[letter] >= current_substring_start:
            current_substring_start = substring[letter] + 1
            current_substring_length = i - substring[letter]
            substring[letter] = i
        else:
            substring[letter] = i
            current_substring_length += 1
            if current_substring_length > longest_substring_sofar:
                longest_substring_sofar = current_substring_length
    return longest_substring_sofar
				\end{lstlisting}		
	\end{columns}
	
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{5. Longest Palindromic Substring}


	\begin{itemize}
	\item Given a string s, return longest palindromic substring in s
	\item \lstinline|"babad" => "bab", "aba"|
	\item Brute Force: e.g. ``abcbd''. Brute force could be to run 2 for loops, for different ranges, longest to shortest and check for palindrome, return first hit of the longest
	\item Better to find centers having palindrome around it, by expanding step by step. Store biggest so far. Take care of Odd and Even lengths. Find lengthier than current biggest.
	\end{itemize}
	


		\begin{lstlisting}[basicstyle=\scriptsize]
def is_palindrome(s):
    return s == s[::-1]
		
def longestPalindromicSubstring_bruteforce(s):
    for length in range(len(s), 0, -1):  # reverse length numbers
        for start_index in range(0, len(s) + 1 - length):  # different starting points
            current_substring = s[start_index:(start_index + length)]
            if is_palindrome(current_substring):
                return current_substring  # return right away because we are checking the longest first
		\end{lstlisting}		


\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{5. Longest Palindromic Substring}

		\begin{lstlisting}[basicstyle=\scriptsize]
def longestPalindromicSubstring(s):
    biggest = s[0]
    step = len(biggest) // 2  # one side
    # odd case
    for center in range(1, len(s) - 1):
        bounds = [center - (1 + step), center + (1 + step)]  # both directions
        while (bounds[0] > -1) and (bounds[1] < len(s)):  # ends
            current_string = s[bounds[0]:bounds[1] + 1]
            if is_palindrome(current_string):
                biggest = current_string
                step = len(biggest) // 2  # find longer next
                bounds[0] -= 1  # make wider
                bounds[1] += 1
            else:
                break
    # even case
    for center in range(step, len(s) - step - 1):
        bounds = [center - step, center + (1 + step)]  # both directions
        while (bounds[0] > -1) and (bounds[1] < len(s)):  # ends
            current_string = s[bounds[0]:bounds[1] + 1]
            if is_palindrome(current_string):
                biggest = current_string
                step = len(biggest) // 2  # find longer next
                bounds[0] -= 1  # make wider
                bounds[1] += 1
            else:
                break
    return biggest
		\end{lstlisting}		

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{6. ZigZag Conversion}


	\begin{itemize}
	\item Write code that will take a string and make zig zag on given number of rows
\lstinline{"Paypal is hiring" ie "PAYPALISHIRING" => |/|/| like order}
	\item Output : ``PAHNAPLSIIGYIR''
	\item Dictionary based solution, each key is for a row value is list of letters in it.
	\item Go on increasing row counter till num, then decreasing till 1 and so on.
	\end{itemize}

		\begin{lstlisting}[basicstyle=\scriptsize]
def convert_zigzag(s, num):
    if num == 1:
        return s
    rows_dict = {row: "" for row in range(1, num + 1)}
    current_row_index = 1
    increment_row_index = True # False for down
    for c in s: # each letter:
        rows_dict[current_row_index] += c
        if (current_row_index == 1) or ((current_row_index < num) and increment_row_index):
            current_row_index += 1
            increment_row_index = True
        else:
            current_row_index -= 1
            increment_row_index = False
    converted_string = ""
    for row in range(1, num+1):
        converted_string += rows_dict[row]
    return converted_string		
				\end{lstlisting}		

	
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{9. Palindrome Number}


	\begin{itemize}
	\item Determine if given integer is palindrome, without converting integer to string. Example121 is, -121 is not
	\item Conversion solution : \lstinline{return (str(x) == str(x)[::-1])}
	\item If number is negative, return False directly, as "-" can not be on right end.
	\item Separate out digits then reverse, and check with original by equality
	\end{itemize}

		\begin{lstlisting}[basicstyle=\scriptsize]
def is_palindrome(x):
    if x < 0:
        return False
    reversed_num = 0
    decimal_step = 0
    while (x // (10 ** decimal_step) !=0):
        reversed_num = (reversed_num * 10) + (x // (10 ** decimal_step) % 10)
        decimal_step += 1

    return (x == reversed_num)
				\end{lstlisting}		

	
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{11. Container With Most Water}


	\begin{itemize}
	\item Build histogram of numbers. With two bars as sides, find which container has most water
	\item For \lstinline{ [1,8,6,2,5,4,8,3,7] = 49}, between first and last
	\item Height as well as wider separation is needed.
	\item Brute force will be to try all pairs and finding max.
	\item Start from both ends and move in from shorter side and check.
	\end{itemize}

		\begin{lstlisting}[basicstyle=\scriptsize]
def maxArea(height):
    start_index = 0
    end_index = len(height) - 1
    largest = 0
    while start_index != end_index:
        next_area = min(height[start_index],height[end_index]) * (end_index - start_index)
        if next_area > largest:
            largest = next_area
        if height[start_index] < height[end_index]:
            start_index += 1
        else:
            end_index -= 1
    return largest
				\end{lstlisting}		

	
\end{frame}

