%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{}
\begin{center}
{\Large Introduction}
\end{center}
\end{frame}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame} \frametitle{What is Swift?}
\begin{itemize}
\item Swift is fast, as close to C as possible
\item Swift is simple and readable, very similar to Python. 
\item Swift is a more efficient, stable and secure programming language as compared to Python.
\item Swift is good for Mobile Apps development, official language for iOS apps.
\item Swift has strong integrated support for automatic differentiation.
\item Swift lets seamlessly import libraries from Python like NumPy, pandas, matplotlib and scikit-learn. 
\item Swift has support from Apple, Google and FastAI.
\end{itemize}
\end{frame}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{}
\begin{center}
{\Large Getting Started}
\end{center}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame} \frametitle{Best way to use Swift}

\begin{itemize}
\item Use Google Colab
\item Copy https://colab.research.google.com/github/tensorflow/ swift/blob/master/notebooks/blank\_swift.ipynb to your Google Drive
\item Rename it properly and start using \ldots
\item If you want to have it locally, then go ahead \ldots
\end{itemize}

\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame} \frametitle{Installation on Windows}
\begin{itemize}
\item NO NEED TO Download RELEASE toolchain and sig from https://swift.org/download/ but get it from "Development Snapshots" of Windows from https://github.com/tensorflow/swift/blob/master/Installation.md

\item \lstinline|gpg.exe --import all-keys.asc| from https://swift.org/keys/all-keys.asc
\item Install exe
\item It gets installed in \lstinline|C:\\Library\\Developer\\Toolchains|
\item Define SDKROOT in Env Variables (..shown in next slide)
\end{itemize}

{\tiny (Note:  The .exe installer for Windows are signed using GnuPG with one of the keys of the Swift open source project. Everyone is strongly encouraged to verify the signatures before using the software.). For Other OSs refer https://swift.org/getting-started/\#installing-swift}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame} \frametitle{Installation on Windows}
\begin{itemize}

\item From an (elevated) "Administrator" x64 Native Tools for VS2019 Command Prompt shell (Follow step 4 mentioned in link above)
\item Set \lstinline|SDKROOT=C:/Library/Developer/Platforms/| \lstinline|Windows.platform/Developer/SDKs/Windows.sdk|
\item Create test.swift with code as \lstinline|print("hello")| and run
\item \lstinline|swiftc -sdk \%SDKROOT\% -I \%SDKROOT\%/usr/lib/swift -L \%SDKROOT\%/usr/lib/swift/windows -emit-executable -o test.exe test.swift|
\item \lstinline|test.exe|
\end{itemize}
{\tiny (Note:  Interpreter mode and direct invocation from VS 2019 are currently not supported on Windows.. Ref: https://github.com/tensorflow/swift/blob/master/Installation.md)}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame} \frametitle{Jupyter Installation on Windows}

Assuming "Swift for Tensorflow" toolchain is already installed

\begin{itemize}
\item git clone https://github.com/google/swift-jupyter.git
\item cd swift-jupyter
\item conda create -n swift-tensorflow python==3.6
\item activate swift-tensorflow
\item conda install jupyter numpy matplotlib
\item python register.py --sys-prefix --swift-python-use-conda --use-conda-shared-libs --swift-toolchain path-to-unknown-Asserts-development.xctoolchain
\end{itemize}

{\tiny (Note:Error "ModuleNotFoundError: No module named '\_lldb'" (Track: https://github.com/google /swift-jupyter/issues/98)}
 
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{}
\begin{center}
{\Large Quick Tour of Swift}
\end{center}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile] \frametitle{Comments}

Like C++, both, single-line \lstinline|//| or multi-line like \lstinline|/*   */|

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile] \frametitle{Variables}

\begin{itemize}
\item \lstinline|let| for constants
\item \lstinline|var| for variables
\item Use \lstinline|var| for temporary variables or variables you want to use for some intermediate calculations.
\item Use \lstinline|let| for things like storing the training data, results, etc. – basically the values that you do not want to change or mess up.
\item Cool feature : use emojis as variable names!

\begin{center}
\includegraphics[width=0.6\linewidth,keepaspectratio]{s4tf4}
\end{center}

\item var $\pi$ = 3.1415925

\end{itemize}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile] \frametitle{Variables}

\begin{itemize}
\item Values are never implicitly converted to another type.
\item Explicitly make an instance of the desired type.
\begin{lstlisting}
let label = "The width is "
let width = 94
let widthLabel = label + String(width)
\end{lstlisting}
\item To include values in strings: Write the value in parentheses, and write a backslash \lstinline|(\)| before the parentheses.
\begin{lstlisting}
let apples = 3
let oranges = 5
let appleSummary = "I have \(apples) apples."
let fruitSummary = "I have \(apples + oranges) pieces of fruit."
\end{lstlisting}
\item Use three double quotation marks \lstinline|(""")| for strings that take up multiple lines.
\end{itemize}


\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile] \frametitle{Data Types}
\begin{itemize}
\item Supports all the common data types, like Integer, String, Float and Double. 
\item Assign any variable with a value, and its type will automatically be inferred by Swift.
\begin{lstlisting}
let marks = 63
let percentage = 70.0
var name = "Sushil"
\end{lstlisting}
\item Type can be specified explicitly as well.
\begin{lstlisting}
let weight: Double = 72.8
\end{lstlisting}
\item Swift will throw an error if the types do not match.
\end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile] \frametitle{Data Structures}
Supports both list and dictionary data structures just like Python, Dict syntax is different though.
\begin{lstlisting}
var shoppingList = ["catfish", "water", "tulips", "blue paint"]
shoppingList[1] = "bottle of water"
shoppingList.append("red apple")
print(shoppingList)

var occupationsDict = [
    "Malcolm": "Captain",
    "Kaylee": "Mechanic",
]
occupationsDict["Jayne"] = "Public Relations"
\end{lstlisting}


\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile] \frametitle{Data Structures}
Empty creation

\begin{lstlisting}
let emptyArray = [String]()
let emptyDictionary = [String: Float]()
\end{lstlisting}

If type information can be inferred, you can write an empty array as [] and an empty dictionary as [:]
\begin{lstlisting}
shoppingList = []
occupations = [:]
\end{lstlisting}

\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile] \frametitle{Working with Loops}

\begin{itemize}
\item Supports all the conventional looping mechanisms (for, while, etc.) but also implements some variations of its own.
\item The three dots in the first example are used to denote ``range'' in Swift. \lstinline|a...b| be values between a and b.
\item If we want to exclude the last number, we can just change the three dots to \lstinline|..<| like \lstinline|a..<b|
\item No indentation as Python but uses curly brackets ``{}'' like C.
\end{itemize}

\begin{lstlisting}
for i in 0...5{
	print(i)
}
var somelist = [1,44,5,6,342]
for item in somelist{
	print(item*2)
}
\end{lstlisting}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile] \frametitle{Working with Loops}

Dictionaries are an unordered collection, so their keys and values are iterated over in an arbitrary order.

\begin{lstlisting}
let interestingNumbers = [
    "Prime": [2, 3, 5, 7, 11, 13],
    "Fibonacci": [1, 1, 2, 3, 5, 8],
    "Square": [1, 4, 9, 16, 25],
]
var largest = 0
for (kind, numbers) in interestingNumbers {
    for number in numbers {
        if number > largest {
            largest = number
        }
    }
}
print(largest) // Prints "25"
\end{lstlisting}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile] \frametitle{Working with Loops}

\begin{itemize}
\item Use while to repeat a block of code until a condition changes. 
\item The condition of a loop can be at the end instead, ensuring that the loop is run at least once.
\end{itemize}

\begin{lstlisting}
var n = 2
while n < 100 {
    n *= 2
}
print(n) // Prints "128"

var m = 2
repeat {
    m *= 2
} while m < 100
print(m) // Prints "128"
\end{lstlisting}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile] \frametitle{Conditionals}

\begin{itemize}
\item Supports conditional statements like \lstinline|if, if..else|
\item Supports even the \lstinline|switch| statement
\end{itemize}

\begin{lstlisting}
let individualScores = [75, 43, 103, 87, 12]
var teamScore = 0
for score in individualScores {
    if score > 50 {
        teamScore += 3
    } else {
        teamScore += 1
    }
}
print(teamScore)
// Prints "11"
\end{lstlisting}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile] \frametitle{Conditionals}

\begin{itemize}
\item Use \lstinline|if| and \lstinline|let| together for missing/\lstinline|nil| values.
\item Represented as optionals. 
\item An optional value either contains a value or contains nil to indicate that a value is missing. 
\item Write a question mark \lstinline|(?)| after the type of a value to mark the value as optional.
\end{itemize}

\begin{lstlisting}
var optionalString: String? = "Hello"
print(optionalString == nil) // Prints "false"

var optionalName: String? = "John Appleseed"
var greeting = "Hello!"
if let name = optionalName {
    greeting = "Hello, \(name)"
}
\end{lstlisting}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile] \frametitle{Optionals}

\begin{itemize}
\item If the optional value is nil, the conditional is false and the code in braces is skipped. 
\item Otherwise, the optional value is unwrapped and assigned to the constant after let, which makes the unwrapped value available inside the block of code.
\item If the optional value is missing, the default value is used instead.
\end{itemize}

\begin{lstlisting}
let nickname: String? = nil
let fullName: String = "John Appleseed"
let informalGreeting = "Hi \(nickname ?? fullName)"
\end{lstlisting}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile] \frametitle{Switch}

Support any kind of data and a wide variety of comparison operations—they aren’t limited to integers and tests for equality.
 
\begin{lstlisting}
let vegetable = "red pepper"
switch vegetable {
case "celery":
    print("Add some raisins and make ants on a log.")
case "cucumber", "watercress":
    print("That would make a good tea sandwich.")
case let x where x.hasSuffix("pepper"):
    print("Is it a spicy \(x)?")
default:
    print("Everything tastes good in soup.")
}
// Prints "Is it a spicy red pepper?"
\end{lstlisting}

Notice how let can be used in a pattern to assign the value that matched the pattern to a constant.

\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile] \frametitle{Functions}

\begin{itemize}
\item Diff w Python: Swift uses the func keyword instead of def and we explicitly mention the data types of the arguments and the return type of the function.
\item Curly brackets “{}” to denote the code block that belongs to this function.
\end{itemize}


\begin{center}
\includegraphics[width=0.8\linewidth,keepaspectratio]{s4tf5}
\end{center}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile] \frametitle{Functions}

\begin{itemize}
\item By default, functions use their parameter names as labels for their arguments. 
\item Write a custom argument label before the parameter name, or write \_ to use no argument label.

\begin{lstlisting}
func greet(_ person: String, on day: String) -> String {
    return "Hello \(person), today is \(day)."
}
greet("John", on: "Wednesday")
\end{lstlisting}

\end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile] \frametitle{Functions}

\begin{lstlisting}
func calculateStatistics(scores: [Int]) -> (min: Int, max: Int, sum: Int) {
    var min = scores[0]
    var max = scores[0]
    var sum = 0
    for score in scores {
        if score > max {
            max = score
        } else if score < min {
            min = score
        }
        sum += score
    }
    return (min, max, sum) // tuple to make a compound value
}
let statistics = calculateStatistics(scores:[5,3,100,3 9])
print(statistics.sum) // Prints "120"
print(statistics.2) // Prints "120"
\end{lstlisting}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile] \frametitle{Functions}
Functions can be nested. Nested functions have access to variables that were declared in the outer function.


\begin{lstlisting}
func returnFifteen() -> Int {
    var y = 10
    func add() {
        y += 5
    }
    add()
    return y
}
returnFifteen()
\end{lstlisting}


\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile] \frametitle{Functions}

Functions are a first-class type. This means that a function can return another function as its value.
\begin{lstlisting}
func makeIncrementer() -> ((Int) -> Int) {
    func addOne(number: Int) -> Int {
        return 1 + number
    }
    return addOne
}
var increment = makeIncrementer()
increment(7)
\end{lstlisting}

\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile] \frametitle{Functions}
A function can take another function as one of its arguments.

\begin{lstlisting}
func hasAnyMatches(list: [Int], condition: (Int) -> Bool) -> Bool {
    for item in list {
        if condition(item) {
            return true
        }
    }
    return false
}
func lessThanTen(number: Int) -> Bool {
    return number < 10
}
var numbers = [20, 19, 7, 12]
hasAnyMatches(list: numbers, condition: lessThanTen)
\end{lstlisting}

\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile] \frametitle{Functions}
\begin{itemize}
\item Functions are actually a special case of closures: blocks of code that can be called later. 
\item The code in a closure has access to things like variables and functions that were available in the scope where the closure was created, even if the closure is in a different scope when it is executed.
\item You can write a closure without a name by surrounding code with braces ({}). Use in to separate the arguments and return type from the body.
\end{itemize}

\begin{lstlisting}
numbers.map({ (number: Int) -> Int in
    let result = 3 * number
    return result
})
\end{lstlisting}

\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile] \frametitle{Functions}
\begin{itemize}
\item You have several options for writing closures more concisely. 
\item When a closure’s type is already known, such as the callback for a delegate, you can omit the type of its parameters, its return type, or both. 
\item Single statement closures implicitly return the value of their only statement.
\end{itemize}

\begin{lstlisting}
let mappedNumbers = numbers.map({ number in 3 * number })
print(mappedNumbers)
// Prints "[60, 57, 21, 36]"
\end{lstlisting}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile] \frametitle{Functions}
\begin{itemize}
\item You can refer to parameters by number instead of by name—this approach is especially useful in very short closures. 
\item A closure passed as the last argument to a function can appear immediately after the parentheses. 
\item When a closure is the only argument to a function, you can omit the parentheses entirely.
\end{itemize}

\begin{lstlisting}
let sortedNumbers = numbers.sorted { $0 > $1 }
print(sortedNumbers)
// Prints "[20, 19, 12, 7]"
\end{lstlisting}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile] \frametitle{Objects and Classes}
\begin{itemize}
\item Use class followed by the class’s name to create a class. 
\item A property declaration in a class is written the same way as a constant or variable declaration, except that it is in the context of a class. 
\item Likewise, method and function declarations are written the same way.
\end{itemize}

\begin{lstlisting}
class Shape {
    var numberOfSides = 0
    func simpleDescription() -> String {
        return "A shape with \(numberOfSides) sides."
    }
}
\end{lstlisting}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile] \frametitle{Objects and Classes}
\begin{itemize}
\item Create an instance of a class by putting parentheses after the class name. 
\item Use dot syntax to access the properties and methods of the instance.
\end{itemize}

\begin{lstlisting}
var shape = Shape()
shape.numberOfSides = 7
var shapeDescription = shape.simpleDescription()
\end{lstlisting}


\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile] \frametitle{Objects and Classes}
Use init to create initializer.

\begin{lstlisting}
var shape = Shape()
class NamedShape {
    var numberOfSides: Int = 0
    var name: String
    init(name: String) {
        self.name = name
    }
    func simpleDescription() -> String {
        return "A shape with \(numberOfSides) sides."
    }
}
\end{lstlisting}

\lstinline|self| is used to distinguish the name property from the name argument to the initializer. 
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile] \frametitle{Objects and Classes}
\begin{itemize}
\item Use \lstinline|deinit| to create a deinitializer if you need to perform some cleanup before the object is deallocated.
\item Subclasses include their superclass name after their class name, separated by a colon. 
\item There is no requirement for classes to subclass any standard root class, so you can include or omit a superclass as needed.
\end{itemize}


\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile] \frametitle{Objects and Classes}
\begin{itemize}
\item Methods on a subclass that override the superclass’s implementation are marked with override—overriding a method by accident, without override, is detected by the compiler as an error. 
\item The compiler also detects methods with override that don’t actually override any method in the superclass.
\end{itemize}


\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile] \frametitle{Objects and Classes}

\begin{lstlisting}
class Square: NamedShape {
    var sideLength: Double
    init(sideLength: Double, name: String) {
        self.sideLength = sideLength
        super.init(name: name)
        numberOfSides = 4
    }
    func area() -> Double {
        return sideLength * sideLength
    }
    override func simpleDescription() -> String {
        return "A square with sides of length \(sideLength)."
    }
}
let test = Square(sideLength: 5.2, name: "my test square")
test.area()
test.simpleDescription()
\end{lstlisting}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile] \frametitle{Python in Swift}

\begin{itemize}
\item Import useful Python libraries from Swift, call their functions, and convert values between Swift and Python seamlessly.
\item In Swift for Tensorflow its \lstinline|import PythonKit|
\end{itemize}

\begin{lstlisting}
import Python

// Load numpy from Python
let np = Python.import("numpy")

// Create an array of zeros
var zeros = np.ones([2, 3])
print(zeros)
\end{lstlisting}
\end{frame}
