%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{}
\begin{center}
{\Large Queue}
\end{center}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}
	\frametitle{The Queue ADT*}
	
			\begin{itemize}

				\item Queue:
								\begin{itemize}

				\item \texttt{size()} (or \texttt{len(s)}) to get the number of items in the queue.
				\item \texttt{enqueue(item)} to add something to the queue.
				\item \texttt{dequeue()} to remove the first element from the queue.
				\item \texttt{peek()} to view the first element of the queue.
			\end{itemize}
			\item Data Structure:
			What kind of data structure should we use to implement a Queue?
				\begin{itemize}
					\item An array
					\item A python list
					\item A linked list
					\item A dict
				\end{itemize}
			\item 
			Only removing on one end and adding on the other? Seems like a DLL will do.
				\end{itemize}

						{*\scriptsize An ADT, or Abstract Data Type, is a description of the behaviour of a data structure.}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}
	\frametitle{Implementing a Linked-List based Queue}
			\begin{tabular}{r | c c}
				Queue operation & DLL operation & Time Complexity \\
				\midrule
				\texttt{size} & \texttt{size} & $O(1)$ \\
				\texttt{enqueue} & \texttt{add\_last} & $O(1)$ \\
				\texttt{dequeue}  & \texttt{remove\_first} & $O(1)$ \\
				\texttt{peek}  & \texttt{head} & $O(1)$ \\
			\end{tabular}
		

				\begin{itemize}
					\item Could we also do this using an array-based list?	
					\item What about an SLL?
					\item No more growing: 	Sure, but only for fixed capacity queues.
					\item Eeyore:	Only if we have the tail pointer.
				\end{itemize}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}
	\frametitle{Why a queue}
		In snake \ldots
			\begin{itemize}
				\item In snake, the body of the snake follows the head.
				\item If we first go left, then right, then every part of the body also needs to go first left then right.
				\item This is like a queue!
			\end{itemize}
		
			Many others?:	But of course there are many other real-world examples.
				\begin{itemize}
					\item Ticket counters,
					\item Traffic jams,
					\item Coffee machines and printers,
					\item Take-out restaurants,
					\item etc.
				\end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}
	\frametitle{Double-Ended Queues: Deques}
		\begin{itemize}
		\item Deques, or Double-Ended Queues, allow both FIFO and LIFO operations in $O(1)$ time.
		\item Hang on \ldots: 	Doesn't that sound familiar?	
		\item Back to DLL: 	This is exactly what a DLL offers!
		\end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}
	\frametitle{\texttt{deque}}
	
	In python we can use a \texttt{deque} called \texttt{d} on which:
	\begin{itemize}
		\item We can \textit{push} with \texttt{d.append}.
		\item We can \textit{pop} with \texttt{d.pop}.
		\item We can \textit{top} with \texttt{d[-1]}
			
		\item We can \textit{enqueue} with \texttt{d.append}.
		\item We can \textit{dequeue} with \texttt{d.popleft}.
		\item We can \textit{peek} with \texttt{d[0]}
			
		\item Oh yeah and if you want, you can also add to the left with \texttt{appendleft}
	\end{itemize}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{}
\begin{center}
{\Large Stack}
\end{center}

\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}
	\frametitle{Stacks: Me and my books}

	\begin{columns}[T]
		\column{0.455\textwidth}
			\begin{center}

					\includegraphics[width=0.7\textwidth]{images/stack_read.jpg}\\

					\includegraphics[width=0.7\textwidth]{images/stack_unread.jpg}\\

{\scriptsize Image By:\thinspace{\itshape Stefan Hugtenburg}}
{\scriptsize Bookcovers and picture in the back by others}
			\end{center}
		\column{0.455\textwidth}
		\begin{itemize}
			\item This is how I used to store books I still wanted to read.
			\item A nice \alert{stack} of books, with new ones going on the top.
			\item After finishing one, I would take the next one from the top.
			\item So after a few weeks\dots
			\item This uses the \alert{LIFO}-principle.
		\end{itemize}
	\end{columns}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}
	\frametitle{LIFO: what!?}
		\begin{itemize}
			\item The \textit{Last-In-First-Out}, or LIFO, principle is the working of a stack.
			\item The last thing we've added to the stack is the first thing we take out.
			\item Similarly the first we have added to the stack, is the last to be taken out.
		\end{itemize}	
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}
	\frametitle{The Stack ADT*}
		\begin{itemize}
			\item The Stack:
				\begin{itemize}
					\item \texttt{size()} (or \texttt{len(s)}) to get the number of items in the stack.
					\item \texttt{push(item)} to add something to the stack.
						
					\item \texttt{pop()} to remove the top element from the stack.
					\item \texttt{top()} to view the top element of the stack.
				\end{itemize}
			\item Data structure?: 
				What kind of data structure should we use to implement a Stack?

				\begin{itemize}
					\item An array
					\item A python list
					\item A linked list
					\item A dict
				\end{itemize}
			\item One end only:
				Only removing and adding on one end? Seems like a DLL will do.
			\end{itemize}

						{*\scriptsize An ADT, or Abstract Data Type, is a description of the behaviour of a data structure.}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}
	\frametitle{Implementing a Linked-List based Stack}
			\begin{tabular}{r | c c}
				Stack operation & DLL operation & Time Complexity \\
				\midrule
				\texttt{size} & \texttt{size} & $O(1)$ \\
				\texttt{push} & \texttt{add\_last} & $O(1)$ \\
				\texttt{pop}  & \texttt{remove\_last} & $O(1)$ \\
				\texttt{top}  & \texttt{tail} & $O(1)$ \\
			\end{tabular}
		
				\begin{itemize}
					\item Could we also do this using an array-based list?	
					\item What about an SLL?
					\item Sure, but it's only amortised $O(1)$. So why would we?
					\item Front = Back: Sure, but we add and remove from the front!
			\end{itemize}

\end{frame}

