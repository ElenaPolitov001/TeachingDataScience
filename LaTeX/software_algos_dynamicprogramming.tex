%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{}
\begin{center}
{\Large Dynamic Programming}
\end{center}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}
	\frametitle{Introduction}
		
			\begin{itemize}
				\item Extension of recursion that further optimists time complexity by storing intermediate values of 
recursion so they don’t have to be re-computed. 
				\item The array/structure that stores these values is 
called a memo, and the process of storing them memoization. 
				\item A ``bottom up” approach uses 
``tabulation” instead of ``memoisation''. 
				\item Memoization is ``top-down'' because, like in the ﬁb(n) 
example, you compute $ﬁb(5)$ before looking for $ﬁb(4)$ which is needed to compute $ﬁb(5)$, whereas a 
bottom-up approach finds $ﬁb(4)$ and puts it in a variable/array before using it to computer $ﬁb(5)$ at 
all. 
				\item Tabulation is more efficient when all sub-problems must be solved at least once to get the final 
result (as in the $ﬁb(n)$ problem) but memoization is faster otherwise because it strictly only 
computers things that need to be computed. 
			\end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}
	\frametitle{Difference}
		
			\begin{itemize}
				\item There’s a difference between divide and conquer (a class of algorithms) and dynamic programming 
(a technique for thinking about/approaching problems). 
\item In divide and conquer, the sub-problems 
don’t overlap. 
\item In DP, they do, and it’s optimal to cache the overlaps via memorization to optimize. 
			\end{itemize}
\end{frame}