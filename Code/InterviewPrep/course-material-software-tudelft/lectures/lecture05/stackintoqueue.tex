\begin{frame}
\frametitle{A classic CS exercise}
\framesubtitle{Something hammer and nails?}	

\begin{problemblock}{Imagine...}
	Consider that we only have access to stacks, but I still want FIFO.\\
	What can I do?
\end{problemblock}
\pause
\begin{answerblock}{Create a stack-based queue}
	Create a queue out of two stacks!
\end{answerblock}
\end{frame}

\begin{frame}
	\frametitle{Let's get this started}
	
	\lstinputlisting{code/queuestack1.py}
	\begin{itemize}
		\item We will use two stacks to model the FIFO behaviour.
	\end{itemize}
\end{frame}

\begin{frame}
	\frametitle{Enqueueueueueing}
	\lstinputlisting{code/queuestack2.py}
	\begin{itemize}
		\item When adding, we just always add to \texttt{s1}.
			\pause
		\item The trick is in when we remove an item.
	\end{itemize}
\end{frame}

\begin{frame}
	\frametitle{Dequeueueueueing}
	\begin{questionblock}{How do we dequeue?}
		\begin{enumerate}[A.]
			\item We always \texttt{pop} from \texttt{s1}.
			\item We always \texttt{pop} from \texttt{s2}, when it is empty pop all of \texttt{s1} into \texttt{s2}.
			\item We always \texttt{pop} all of \texttt{s2} onto \texttt{s1}, then we pop from \texttt{s1}.
			\item I don't know.
		\end{enumerate}
	\end{questionblock}
\end{frame}

\begin{frame}
	\frametitle{Reverse when needed}
	\lstinputlisting{code/queuestack3.py}
\end{frame}
