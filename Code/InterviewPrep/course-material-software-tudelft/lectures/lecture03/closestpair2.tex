\section{Back to closest pair of points}
\label{sec:back_to_closest_pair_of_points}


\begin{frame}
	\frametitle{The algorithm}
	\begin{columns}
		\column{0.705\textwidth}
	\begin{algorithmic}
		\State Sort all points by x-coordinate
		\Function{Closest-Pair}{$p_1,\dots,p_n$}
			\If{n=1}
				\State \Return $\infty$
			\EndIf

			\State $L \gets$ \alert<2>{median} $x$-coordinate
			\State $\delta_1 \gets$ \Call{Closest-Pair}{Points left of $L$}
			\State $\delta_2 \gets$ \Call{Closest-Pair}{Points right of $L$}
			\State $\delta \gets \min(\delta_1,\delta_2)$
			\State get list of all points within $\delta$ from L.
			\State sort this list by y-coordinate
			\State Scan by y-order, compare every point to the next 11 and update $\delta$ as you go.
			\State \Return $\delta$
		\EndFunction
	\end{algorithmic}
		\pnote{Why not the average?}
		\column{0.205\textwidth}
		\begin{questionblock}{}
			What is the recurrence equation for the run time?	
		\end{questionblock}	
		\begin{answerblock}{}
			\small
			$T(n) =2T(n/2) + O(n\log n)$	
		\end{answerblock}
	\end{columns}
	
\end{frame}

\begin{frame}
	\frametitle{Back to closest pair of points}
	\input{figures/tikz/closestpair.tex}
	\begin{problemblock}{The recurrence equation}
		\small
		$T(n) =2T(n/2) + \Theta(n \log n)$	\\
		\only<1>{
		Which part of the algorithm uses strictly more time?
		\begin{enumerate}[A.]
			\item Work in the leaves: $n^{\log_b a}$.
			\item Work in the root node: $f(n)$.
			\item Evenly spread throughout the tree.
			\item We cannot apply the master method.
		\end{enumerate}
	}
	\end{problemblock}

	\pause
	\begin{answerblock}{Case ...?}
		\small
		$a = 2, b =2, n^{\log_b a} = n^{\log_2 2} = n^1$\\
		$f(n)$ is $\Theta(n \log n)$\\
		$f(n)$ is not $O(n^{1-\epsilon})$ (so \alert{not} case 1)\\
		\pause
		$f(n)$ is not $\Theta(n)$ (so \alert{not} case 2)\\
		\pause
		$f(n)$ is not $\Omega(n^{1+\epsilon})$ (so \alert{not} case 3)
		{\scriptsize We can show that $n^c$ is $\Omega(\log n)$ for any $c>0$, so $n^{1+c}$ is $\Omega(n \log n)$.}
	\end{answerblock}
\end{frame}

\begin{frame}
	\frametitle{Whelp... That's great}
	\pause
	\begin{center}
		\includegraphics[width=0.8\textwidth]{figures/hut.jpg}
		\hspace*{15pt}\hbox{\scriptsize Image By:\thinspace{\itshape Dave Young}}
		% https://www.flickr.com/photos/dcysurfer/26103416154
	\end{center}
\end{frame}

\begin{frame}
	\frametitle{Can we do better?}
	\begin{columns}
		\column{0.705\textwidth}
	\begin{algorithmic}
		\State Sort all points by x-coordinate
		\Function{Closest-Pair}{$p_1,\dots,p_n$}
			\If{n=1}
				\State \Return $\infty$
			\EndIf
			\State $L \gets$ median $x$-coordinate
			\State $\delta_1 \gets$ \Call{Closest-Pair}{Points left of $L$}
			\State $\delta_2 \gets$ \Call{Closest-Pair}{Points right of $L$}
			\State $\delta \gets \min(\delta_1,\delta_2)$
			\State get list of all points within $\delta$ from L.
			\State \alert{sort this list by y-coordinate}
			\State Scan by y-order, compare every point to the next 11 and update $\delta$ as you go.
			\State \Return $\delta$
		\EndFunction
	\end{algorithmic}
		\column{0.205\textwidth}
		\pause
		\begin{questionblock}{}
			Do we need to sort every time?
		\end{questionblock}	
		\pause
		\begin{answerblock}{}
			No! How about just once before we start?
		\end{answerblock}
	\end{columns}
	
\end{frame}

\begin{frame}
	\frametitle{Back to closest pair of points}
	\input{figures/tikz/closestpair.tex}
	\begin{problemblock}{The recurrence equation}
		\small
		$T(n) =2T(n/2) + O(n)$	\\
		\only<1>{
		Which part of the algorithm uses strictly more time?
		\begin{enumerate}[A.]
			\item Work in the leaves: $n^{\log_b a}$.
			\item Work in the root node: $f(n)$.
			\item Evenly spread throughout the tree.
			\item We cannot apply the master method.
		\end{enumerate}
	}
	\end{problemblock}

	\pause
	\begin{answerblock}{Case ...?}
		\small
		$a = 2, b =2, n^{\log_b a} = n^{\log_2 2} = n^1$\\
		$f(n)$ is $\Theta(n)$\\
		So case 2 of the master method (work is evenly spread)
	\end{answerblock}
\end{frame}
