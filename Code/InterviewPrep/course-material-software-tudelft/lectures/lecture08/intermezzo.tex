\section{Intermezzo}
\label{sec:intermezzo}

\begin{frame}
	\frametitle{Intermezzo: Databases}

	$\left. 
		\begin{array}{rl} 
			\scriptstyle\mathtt{UPDATE~clause} & \{ \mathtt{UPDATE\ country} \\
				\scriptstyle\mathtt{SET~clause} & \{ \mathtt{SET\ population =~} \overbrace{\mathtt{population + 1}}^\mathtt{expression} \\ 
				\scriptstyle\mathtt{WHERE~clause} & \{ \mathtt{WHERE}\ \underbrace{\mathtt{name =} \underbrace{\mathtt{'USA'}}_{expression}}_{predicate};
		\end{array}
	\right\} \scriptstyle\texttt{statement}$
\end{frame}

\begin{frame}
	\frametitle{Large-scale databases}
	\begin{itemize}
		\item Databases come in all shapes and sizes.
			\pause
		\item Many are tuple-based (or \textit{relational}).
			\pause
		\item And these things can grow very large! Millions of records.
			\pause
		\item So binary searching, instead of linear searching can help a lot!
			\pause
		\item To this end they use B-trees (generalised binary search trees).
			\pause
		\item Searching goes down to 30~ish comparisons instead of a million.
	\end{itemize}
	
\end{frame}

\begin{frame}
	\frametitle{Btree advantages}
	\framesubtitle{\url{https://en.wikipedia.org/wiki/B-tree\#Advantages\_of\_B-tree_usage_for_databases}}
	\begin{itemize}
		\item keeps keys in sorted order for sequential traversing
		\item uses a hierarchical index to minimise the number of disk reads
		\item uses partially full blocks to speed insertions and deletions
		\item keeps the index balanced with a recursive algorithm
	\end{itemize}
	\pause
	\begin{block}{TL;DR}
		It helps :D
	\end{block}	
\end{frame}
